{"version":3,"sources":["ng://ngx-autosize/lib/autosize.directive.ts","ng://ngx-autosize/lib/autosize.module.ts"],"names":["AutosizeDirective","element","_zone","this","onlyGrow","useImportant","retries","_destroyed$","ReplaySubject","nativeElement","tagName","_findNestedTextArea","textAreaEl","style","overflow","_onTextAreaFound","prototype","onInput","textArea","adjust","ngOnDestroy","next","complete","ngAfterContentChecked","ngOnChanges","changes","_this","querySelector","shadowRoot","console","warn","setTimeout","runOutsideAngular","fromEvent","window","pipe","takeUntil","debounceTime","distinctUntilChanged","subscribe","run","inputsChanged","currentText","value","_oldContent","offsetWidth","_oldWidth","clone","cloneNode","parent_1","parentNode","visibility","appendChild","height","scrollHeight","willGrow","offsetHeight","lineHeight","_getLineHeight","rowsCount","styleAttribute","minRows","maxRows","setAttribute","removeChild","parseInt","isNaN","getComputedStyle","styles","fontSize","getPropertyValue","Math","floor","replace","Directive","args","selector","ElementRef","NgZone","Input","HostListener","AutosizeModule","NgModule","declarations","imports","exports"],"mappings":"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","sourcesContent":["import {\n    ElementRef,\n    HostListener,\n    Directive,\n    Input,\n    NgZone, OnDestroy, OnChanges, AfterContentChecked\n} from '@angular/core';\nimport {fromEvent, ReplaySubject} from 'rxjs';\n\nimport {debounceTime, distinctUntilChanged, takeUntil} from 'rxjs/operators';\n\nconst MAX_LOOKUP_RETRIES = 3;\n\n@Directive({\n    selector: '[autosize]'\n})\n\nexport class AutosizeDirective implements OnDestroy, OnChanges, AfterContentChecked {\n    @Input() minRows: number;\n    @Input() maxRows: number;\n    @Input() onlyGrow = false;\n    @Input() useImportant = false;\n\n    private retries = 0;\n    private textAreaEl: any;\n\n    private _oldContent: string;\n    private _oldWidth: number;\n\n    private _destroyed$ = new ReplaySubject(1);\n\n    @HostListener('input', ['$event.target'])\n    onInput(textArea: HTMLTextAreaElement): void {\n        this.adjust();\n    }\n\n    constructor(\n        public element: ElementRef,\n        private _zone: NgZone\n    ) {\n        if (this.element.nativeElement.tagName !== 'TEXTAREA') {\n            this._findNestedTextArea();\n\n        } else {\n            this.textAreaEl = this.element.nativeElement;\n            this.textAreaEl.style.overflow = 'hidden';\n            this._onTextAreaFound();\n        }\n    }\n\n    ngOnDestroy() {\n        this._destroyed$.next(true);\n        this._destroyed$.complete();\n    }\n\n    ngAfterContentChecked() {\n        this.adjust();\n    }\n\n    ngOnChanges(changes) {\n        this.adjust(true);\n    }\n\n    _findNestedTextArea() {\n        this.textAreaEl = this.element.nativeElement.querySelector('TEXTAREA');\n\n        if (!this.textAreaEl && this.element.nativeElement.shadowRoot) {\n            this.textAreaEl = this.element.nativeElement.shadowRoot.querySelector('TEXTAREA');\n        }\n\n        if (!this.textAreaEl) {\n            if (this.retries >= MAX_LOOKUP_RETRIES) {\n                console.warn('ngx-autosize: textarea not found');\n\n            } else {\n                this.retries++;\n                setTimeout(() => {\n                    this._findNestedTextArea();\n                }, 100);\n            }\n            return;\n        }\n\n        this.textAreaEl.style.overflow = 'hidden';\n        this._onTextAreaFound();\n\n    }\n\n    _onTextAreaFound() {\n        this._zone.runOutsideAngular(() => {\n            fromEvent(window, 'resize')\n                .pipe(\n                    takeUntil(this._destroyed$),\n                    debounceTime(200),\n                    distinctUntilChanged()\n                )\n                .subscribe(() => {\n                    this._zone.run(() => {\n                        this.adjust();\n                    });\n                });\n        });\n        setTimeout(() => {\n            this.adjust();\n        });\n    }\n\n    adjust(inputsChanged = false): void {\n        if (this.textAreaEl) {\n\n            const currentText = this.textAreaEl.value;\n\n            if (\n                inputsChanged === false &&\n                currentText === this._oldContent &&\n                this.textAreaEl.offsetWidth === this._oldWidth\n            ) {\n                return;\n            }\n\n            this._oldContent = currentText;\n            this._oldWidth = this.textAreaEl.offsetWidth;\n\n            const clone = this.textAreaEl.cloneNode(true);\n            const parent = this.textAreaEl.parentNode;\n            clone.style.visibility = 'hidden';\n            parent.appendChild(clone);\n\n            clone.style.overflow = 'auto';\n            clone.style.height = 'auto';\n\n            let height = clone.scrollHeight;\n            const willGrow = height > this.textAreaEl.offsetHeight;\n\n            if (this.onlyGrow === false || willGrow) {\n                const lineHeight = this._getLineHeight();\n                const rowsCount = height / lineHeight;\n\n                let styleAttribute = '';\n\n                if (this.minRows && this.minRows >= rowsCount) {\n                    height = this.minRows * lineHeight;\n\n                } else if (this.maxRows && this.maxRows <= rowsCount) {\n                    height = this.maxRows * lineHeight;\n                    styleAttribute += 'overflow: auto;';\n\n                } else {\n                    styleAttribute += 'overflow: hidden;';\n                }\n\n                styleAttribute += `height: ${height}px`;\n\n                styleAttribute += this.useImportant ? '!important;' : ';';\n\n                this.textAreaEl.setAttribute('style', styleAttribute);\n            }\n\n            parent.removeChild(clone);\n        }\n    }\n\n    private _getLineHeight() {\n        let lineHeight = parseInt(this.textAreaEl.style.lineHeight, 10);\n        if (isNaN(lineHeight) && window.getComputedStyle) {\n            const styles = window.getComputedStyle(this.textAreaEl);\n            lineHeight = parseInt(styles.lineHeight, 10);\n        }\n\n        if (isNaN(lineHeight)) {\n            const fontSize = window.getComputedStyle(this.textAreaEl, null).getPropertyValue('font-size');\n            lineHeight = Math.floor(parseInt(fontSize.replace('px', ''), 10) * 1.5);\n        }\n\n        return lineHeight;\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { AutosizeDirective } from './autosize.directive';\n\n@NgModule({\n  declarations: [AutosizeDirective],\n  imports: [\n  ],\n  exports: [AutosizeDirective]\n})\nexport class AutosizeModule { }\n"]}